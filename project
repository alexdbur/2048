import sys
import random
import os
import pygame

import pygame as pg
from pygame import *
from time import sleep

# Use variables to specify parameters first
WINDOW_WIDTH = 300  # Game screen width and height
WINDOW_HEIGHT = 300
WHITE = (255, 255, 255)
Image_W = 64
Image_h = 64
FPS = 45
icon = pygame.image.load('icon.ico')
pygame.display.set_icon(icon)
# pygame initialization
pg.init()

# Specify global variables, objects

table = [[0 for _ in range(4)] for _ in range(4)]
newItemTable = [[0 for _ in range(4)] for _ in range(4)]
moveTable = [[0 for _ in range(4)] for _ in range(4)]
oldTable = [[0 for _ in range(4)] for _ in range(4)]
spriteTable = [[] for _ in range(4)]
imgTable = {0: [], 2: [], 4: [], 8: [], 16: [], 32: [], 64: [],
            128: [], 256: [], 512: [], 1024: [], 2048: []}
allSprite = pg.sprite.Group()
font = pg.font.Font(os.path.join('pictures', 'hsc.ttf'), 24)


class Background(pg.sprite.Sprite):  # background sprite category
    def __init__(self, image_file, location):
        super().__init__()  # call Sprite initializer
        self.raw_image = pg.image.load(image_file).convert_alpha()
        self.image = pg.transform.smoothscale(self.raw_image, (300, 300))
        self.rect = self.image.get_rect()
        self.rect.left, self.rect.top = location
        self.width = 300
        self.height = 300


class Block(pg.sprite.Sprite):  # Wizard category of each block
    def __init__(self, width, height, x, y, image_index):
        super().__init__()
        # Load picture
        self.image = imgTable[image_index][0]
        # Return location
        self.rect = self.image.get_rect()
        # Positioning
        self.rect.topleft = (x, y)
        self.width = width
        self.height = height

    def update(self, i, j, direction, finish_animation, finish_move_animation):
        global moveTable
        global table
        global newItemTable
        global oldTable
        bx, by = self.rect.topleft
        if finish_animation:
            self.rect.topleft = (10 + 64 * j + 8 * j + 1, 10 + 64 * i + 8 * i)
            # Move back first 10+64*j+8*j, 10+64*i+8*i
            self.image = imgTable[table[i][j]][0]
        else:
            if not finish_move_animation:
                if moveTable[i][j] != 0:
                    if direction == 1:  # up
                        self.rect.topleft = (bx, by - 18)
                    elif direction == 2:  # down
                        self.rect.topleft = (bx, by + 18)
                    elif direction == 3:  # left
                        self.rect.topleft = (bx - 18, by)
                    else:  # right
                        self.rect.topleft = (bx + 18, by)
                    moveTable[i][j] -= 0.25
                    self.image = imgTable[oldTable[i][j]][0]
            else:
                if moveTable[i][j] == 0:
                    if newItemTable[i][j] != 0:
                        newItemTable[i][j] -= 0.25
                        wah = int(newItemTable[i][j] / 0.25 + 1)
                        self.rect.topleft = (
                            10 + 64 * j + 8 * j + (32 - 8 * (4 - wah)), 10 + 64 * i + 8 * i + (32 - 8 * (4 - wah)))
                        # Move back first 10+64*j+8*j, 10+64*i+8*i
                        self.image = imgTable[table[i][j]][5 - wah]
                    else:
                        self.rect.topleft = (10 + 64 * j + 8 * j + 1, 10 + 64 * i + 8 * i)
                        self.image = imgTable[table[i][j]][0]

            # A grid of flowers 4 times to run, and finally 4 times
            # to zoom in and out the picture, once moved 18px,


# Settings window
main_clock = pg.time.Clock()
screen = pg.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
# Display window according to settings
pg.display.set_caption("2048 by alexdbur")
# Set program title
BackGround = Background(os.path.join('pictures', 'bg.png'), [
    0, 0])  # Designated background property


def random_new_item():
    while True:
        for i in range(3, -1, -1):  # y
            for j in range(4):  # x
                if table[i][j] == 0:
                    if random.randint(1, 16) == 1:
                        if random.random() > 0.5:
                            table[i][j] = 2
                        else:
                            table[i][j] = 4
                        return i, j


def init():
    # Random number two grids
    rn = random.randint(1, 4)  # random Number Three chances to choose from
    if rn == 1:
        position = random.randint(8, 16) - 1
        table[position % 4][position // 4] = 2
        position = random.randint(1, position) - 1
        table[position % 4][position // 4] = 2
    elif rn == 2:
        position = random.randint(8, 16) - 1
        table[position % 4][position // 4] = 4
        position = random.randint(1, position) - 1
        table[position % 4][position // 4] = 2
    else:
        position = random.randint(8, 16) - 1
        table[position % 4][position // 4] = 2
        position = random.randint(1, position) - 1
        table[position % 4][position // 4] = 4

    # First generate a list of pictures
    for i in range(1, 12, 1):
        image_file = os.path.join('pictures', str(pow(2, i)) + '.png')
        tmp_raw_img = pg.image.load(image_file).convert_alpha()
        tmp_img = pg.transform.smoothscale(tmp_raw_img, (Image_W, Image_h))
        imgTable[pow(2, i)].append(tmp_img)
        for j in range(4):
            tmp_img = pg.transform.smoothscale(tmp_raw_img, (j * 16, j * 16))
            imgTable[pow(2, i)].append(tmp_img)
    # 0 plus
    image_file = os.path.join('pictures', '0.png')
    tmp_raw_img = pg.image.load(image_file).convert_alpha()
    tmp_img = pg.transform.smoothscale(tmp_raw_img, (Image_W, Image_h))
    imgTable[0].append(tmp_img)
    for j in range(4):
        tmp_img = pg.transform.smoothscale(tmp_raw_img, (j * 16, j * 16))
        imgTable[0].append(tmp_img)

    for i in range(4):
        for j in range(4):
            spriteTable[i].append(
                Block(Image_W, Image_h, 10 + 64 * j + 8 * j + 1, 10 + 64 * i + 8 * i, table[i][j]))
            allSprite.add(spriteTable[i][j])


# TheIndex !
# 0,0 0,1 0,2 0,3
# 1,0 1,1 1,2 1,3
# 2,0 2,1 2,2 2,3
# 3,0 3,1 3,2 3,3


def show_game_over(score):
    # Add painting
    print("Game Over!")
    while True:
        background2 = Background(os.path.join('pictures', 'background.png'), [
            0, 0])  # Designated background2 property
        text = font.render("You lose!", True, (255, 255, 255))
        text2 = font.render("Congratulations on your total: " + str(score) + " points", True, (255, 255, 255))
        text3 = font.render("Press [ENTER] to replay, [ESC] to close", True, (255, 255, 255))
        print(score)
        for EVENT in pg.event.get():
            if EVENT.type == pg.QUIT:  # Judgment to close the program
                return  # Code to close the program

        keys = pg.key.get_pressed()
        if keys[K_ESCAPE]:
            print("Exiting")
            return
        if keys[K_RETURN]:
            print("Restarting")
            os.execl(sys.executable, sys.executable, *sys.argv)
        screen.blit(background2.image, background2.rect)
        screen.blit(text, (20, 20))
        screen.blit(text2, (20, 80))
        screen.blit(text3, (20, 140))
        pg.display.update()
        main_clock.tick(FPS)
    # os.execl(sys.executable, sys.executable, *sys.argv)


def no_more_step(field):
    fulled = True
    for i in range(4):  # y
        for j in range(4):  # x
            if field[i][j] == 0:
                fulled = True
                break
    if fulled:
        for i in range(3, 0, -1):  # y
            for j in range(4):  # x
                if field[i][j] != 0:
                    if field[i - 1][j] == field[i][j]:
                        return False
                    if field[i - 1][j] == 0:
                        return False
        for i in range(3):  # y
            for j in range(4):  # x
                if field[i][j] != 0:
                    if field[i + 1][j] == field[i][j]:
                        return False
                    if field[i + 1][j] == 0:
                        return False
        for i in range(3, 0, -1):  # x
            for j in range(4):  # y
                if field[j][i] != 0:
                    if field[j][i - 1] == field[j][i]:
                        return False
                    if field[j][i - 1] == 0:
                        return False
        for i in range(3):  # x
            for j in range(4):  # y
                if field[j][i] != 0:
                    if field[j][i + 1] == field[j][i]:
                        return False
                    if field[j][i + 1] == 0:
                        return False
        return True


def movable(field, direction):
    if direction == 1:
        for i in range(3, 0, -1):  # y
            for j in range(4):  # x
                if field[i][j] != 0:
                    if field[i - 1][j] == field[i][j]:
                        return True
                    if field[i - 1][j] == 0:
                        return True

    elif direction == 2:
        for i in range(3):  # y
            for j in range(4):  # x
                if field[i][j] != 0:
                    if field[i + 1][j] == field[i][j]:
                        return True
                    if field[i + 1][j] == 0:
                        return True
    elif direction == 3:
        for i in range(3, 0, -1):  # x
            for j in range(4):  # y
                if field[j][i] != 0:
                    if field[j][i - 1] == field[j][i]:
                        return True
                    if field[j][i - 1] == 0:
                        return True
    else:
        for i in range(3):  # x
            for j in range(4):  # y
                if field[j][i] != 0:
                    if field[j][i + 1] == field[j][i]:
                        return True
                    if field[j][i + 1] == 0:
                        return True
    return False


def move(direction):
    global moveTable
    global table
    global oldTable
    for i in range(4):
        for j in range(4):
            newItemTable[i][j] = 0
            moveTable[i][j] = 0
            oldTable[i][j] = table[i][j]
    need_move = [[True for _ in range(4)] for _ in range(4)]
    if direction == 1:  # up
        # From top to bottom, left to right, arrange first
        for i in range(1, 4, 1):  # y
            for j in range(4):  # x
                if table[i][j] != 0:
                    for k in range(i - 1, -1, -1):  # From bottom to top
                        if table[k][j] == 0:
                            table[k][j] = table[k + 1][j]
                            table[k + 1][j] = 0
                            if k == 0:
                                moveTable[i][j] += i - k
                        elif table[k][j] != 0:
                            moveTable[i][j] += i - k - 1
                            break

        print("up")
        # From bottom to top, left to right, check
        for i in range(3, 0, -1):  # y
            for j in range(4):  # x
                if need_move[i][j]:
                    if table[i][j] == table[i - 1][j] and table[i][j] != 0:
                        # moveTable[i][j]+=1
                        table[i - 1][j] *= 2
                        newItemTable[i - 1][j] = 1
                        need_move[i - 1][j] = False
                        table[i][j] = 0

        # From top to bottom, left to right, organized
        for i in range(1, 4, 1):  # y
            for j in range(4):  # x
                if table[i][j] != 0:
                    if table[i - 1][j] == 0:
                        table[i - 1][j] = table[i][j]
                        table[i][j] = 0
                        # moveTable[i][j]+=i-1-k
                        if newItemTable[i][j] == 1:  # Row change table
                            newItemTable[i - 1][j] = 1
                            newItemTable[i][j] = 0

    elif direction == 2:
        # From bottom to top, left to right, arrange first
        for i in range(2, -1, -1):  # y
            for j in range(4):  # x
                if table[i][j] != 0:
                    for k in range(i + 1, 4, 1):  # Top to bottom
                        if table[k][j] == 0:
                            table[k][j] = table[k - 1][j]
                            table[k - 1][j] = 0
                            if k == 3:
                                moveTable[i][j] += k - i
                        elif table[k][j] != 0:
                            moveTable[i][j] += k - i - 1
                            break

        print("down")
        # From top to bottom, left to right, check
        for i in range(3):  # y
            for j in range(4):  # x
                if need_move[i][j]:
                    if table[i][j] == table[i + 1][j] and table[i][j] != 0:
                        # moveTable[i][j]+=1
                        table[i + 1][j] *= 2
                        newItemTable[i + 1][j] = 1
                        need_move[i + 1][j] = False
                        table[i][j] = 0

        # From bottom to top, left to right, organized
        for i in range(2, -1, -1):  # y
            for j in range(4):  # x
                if 0 != table[i][j]:
                    if table[i + 1][j] == 0:
                        table[i + 1][j] = table[i][j]
                        table[i][j] = 0
                        # moveTable[i][j]+=i-1-k
                        if newItemTable[i][j] == 1:
                            newItemTable[i + 1][j] = 1
                            newItemTable[i][j] = 0

    elif direction == 3:
        for i in range(1, 4, 1):  # x
            for j in range(4):  # y
                if 0 != table[j][i]:
                    for k in range(i - 1, -1, -1):
                        if table[j][k] == 0:
                            table[j][k] = table[j][k + 1]
                            table[j][k + 1] = 0
                            if k == 0:
                                moveTable[j][i] += i - k
                        elif table[j][k] != 0:
                            moveTable[j][i] += i - k - 1
                            break

        print("left")
        # From again to left, from top to bottom, check
        for i in range(3, 0, -1):  # x
            for j in range(4):  # y
                if need_move[j][i]:
                    if table[j][i] == table[j][i - 1] and table[j][i] != 0:
                        # moveTable[i][j]+=1
                        table[j][i - 1] *= 2
                        newItemTable[j][i - 1] = 1
                        need_move[j][i - 1] = False
                        table[j][i] = 0

        # From left to again, from top to bottom, organized
        for i in range(1, 4, 1):  # x
            for j in range(4):  # y
                if 0 != table[j][i]:
                    if table[j][i - 1] == 0:
                        table[j][i - 1] = table[j][i]
                        table[j][i] = 0
                        # moveTable[i][j]+=i-1-k
                        if newItemTable[j][i] == 1:
                            newItemTable[j][i - 1] = 1
                            newItemTable[j][i] = 0

    else:
        for i in range(2, -1, -1):  # x
            for j in range(4):  # y
                if 0 != table[j][i]:
                    for k in range(i + 1, 4, 1):
                        if table[j][k] == 0:
                            table[j][k] = table[j][k - 1]
                            table[j][k - 1] = 0
                            if k == 3:
                                moveTable[j][i] += k - i
                        elif table[j][k] != 0:
                            moveTable[j][i] += k - i - 1
                            break

        print("right")
        for i in range(3):  # x
            for j in range(4):  # y
                if need_move[j][i]:
                    if table[j][i] == table[j][i + 1] and table[j][i] != 0:
                        # moveTable[i][j]+=1
                        table[j][i + 1] *= 2
                        newItemTable[j][i + 1] = 1
                        need_move[j][i + 1] = False
                        table[j][i] = 0

        # From again to left, from top to bottom, organized
        for i in range(2, -1, -1):  # x
            for j in range(4):  # y
                if table[j][i] != 0:
                    if table[j][i + 1] == 0:
                        table[j][i + 1] = table[j][i]
                        table[j][i] = 0
                        # moveTable[i][j]+=i-1-k
                        if newItemTable[j][i] == 1:  # Row change table
                            newItemTable[j][i + 1] = 1
                            newItemTable[j][i] = 0

    x, y = random_new_item()
    newItemTable[x][y] = 1


def main():
    init()
    global table
    direction = 0
    finish_animation = True
    finish_move_animation = False
    while True:
        for EVENT in pg.event.get():
            if EVENT.type == pg.QUIT:  # Judgment to close the program
                return
        if not finish_animation:
            for i in range(4):  # y
                for j in range(4):  # x
                    spriteTable[i][j].update(
                        i, j, direction, finish_animation, finish_move_animation)

            fl = False
            flag = False
            finish_move_animation = False
            for i in range(3, -1, -1):  # y
                for j in range(4):  # x
                    if moveTable[i][j] == 0:
                        fl = True
                    else:
                        fl = False
                        break
                if not fl:
                    break
            for i in range(3, -1, -1):  # y
                for j in range(4):  # x
                    if newItemTable[i][j] == 0 and moveTable[i][j] == 0:
                        flag = True
                    else:
                        flag = False
                        break
                if not flag:
                    break
            if fl:
                finish_move_animation = True
            if flag:
                finish_animation = True

        #            print("MoveTable:")
        #            for k in range(4):#y
        #                for w in range(4):#x
        #                    print(moveTable[k][w],end=" ")
        #                print()
        #            print(" Table:")
        #            for i in range(4):#y
        #                for j in range(4):#x
        #                    print(table[i][j],end=" ")
        #                print()
        #            print("newItemTable")
        #            for i in range(4):#y
        #                for j in range(4):#x
        #                    print(newItemTable[i][j],end=" ")
        #                print()

        elif finish_move_animation and finish_animation:
            for i in range(4):  # y
                for j in range(4):  # x
                    spriteTable[i][j].update(
                        i, j, direction, finish_animation, finish_move_animation)
            finish_move_animation = False
            score = 0
            for i in range(4):  # y
                for j in range(4):  # x
                    spriteTable[i][j].update(
                        i, j, direction, finish_animation, finish_move_animation)
                    score += table[i][j]
            if no_more_step(table):
                for i in range(4):  # y
                    for j in range(4):  # x
                        table[i][j] = 0
                        spriteTable[i][j].update(i, j, direction, True, True)
                sleep(2)
                show_game_over(score)
                return
        else:
            keys = pg.key.get_pressed()
            if keys[K_UP]:
                direction = 1
            if keys[K_DOWN]:
                direction = 2
            if keys[K_LEFT]:
                direction = 3
            if keys[K_RIGHT]:
                direction = 4

            if keys[K_UP] or keys[K_DOWN] or keys[K_LEFT] or keys[K_RIGHT]:
                if movable(table, direction):
                    move(direction)
                    finish_animation = False
                else:
                    print("Can't move this step!")

        screen.blit(BackGround.image, BackGround.rect)
        allSprite.draw(screen)
        pg.display.update()
        main_clock.tick(FPS)


if __name__ == '__main__':
    main()
    pg.quit()
